1. Сортировка выбором (Selection Sort) Что делает: Находит минимальный элемент в неотсортированной части массива и помещает его в начало. Как работает: На каждом шаге алгоритм 1.ищет минимальный элемент среди оставшихся, меняет его местами с текущим элементом, уменьшая неотсортированную часть массива. Сложность: O(n²) во всех случаях.

2. Сортировка обменом (Bubble Sort) Что делает: Последовательно сравнивает и меняет местами соседние элементы, если они находятся в неправильном порядке. Как работает: Проходит по массиву несколько раз, на каждой итерации "всплывает" самый большой элемент в конец. Процесс повторяется до полной сортировки. Сложность: O(n²).

3. Сортировка вставками (Insertion Sort) Что делает: Постепенно строит отсортированную часть массива, вставляя каждый новый элемент в правильную позицию. Как работает: Начинает со второго элемента, сравнивает его с предыдущими и вставляет на нужное место в отсортированной части. Повторяется для всех элементов. Сложность: O(n²).

4. Сортировка слиянием (Merge Sort) Что делает: Рекурсивно делит массив на две части, сортирует их и объединяет в отсортированный массив. Как работает: Разделяет массив пополам до тех пор, пока не останутся массивы из одного элемента. Затем сливает их в упорядоченном порядке. Сложность: O(n log n).

5. Сортировка Шелла (Shell Sort) Что делает: Улучшенная версия сортировки вставками, сортирующая элементы на определённом расстоянии друг от друга. Как работает: Использует последовательность промежутков (gaps). Начинает с большого gap, уменьшает его на каждом шаге, пока не дойдет до 1. На каждом этапе сортирует элементы, отстоящие на gap друг от друга. Сложность: Зависит от выбора последовательности gaps, в среднем O(n log² n).

6. Быстрая сортировка (Quick Sort) Что делает: Выбирает опорный элемент и разделяет массив на две части: элементы меньше опорного и больше опорного. Как работает: Рекурсивно сортирует подмассивы слева и справа от опорного элемента. Процесс повторяется до полной сортировки. Сложность: O(n log n) в среднем, O(n²) в худшем случае.

7. Пирамидальная сортировка (Heap Sort) Что делает: Строит из массива двоичную кучу (heap) и последовательно извлекает максимальные элементы. Как работает: Сначала преобразует массив в max-heap. Затем извлекает корень (максимальный элемент) и помещает его в конец массива. Повторяет процесс для уменьшенной кучи. Сложность: O(n log n).

8. Последовательный поиск (Linear Search) Что делает: Поочерёдно проверяет каждый элемент массива直到 находит искомый. Как работает: Начинает с первого элемента, сравнивает с искомым значением. Если совпадает - возвращает индекс, иначе переходит к следующему. Сложность: O(n).

9. Бинарный поиск (Binary Search) Что делает: Ищет элемент в отсортированном массиве, многократно деля интервал поиска пополам. Как работает: Сравнивает искомый элемент со средним элементом массива. Если меньше - ищет в левой половине, если больше - в правой. Процесс повторяется до нахождения элемента. Сложность: O(log n).

10. Интерполяционный поиск (Interpolation Search) Что делает: Улучшенный бинарный поиск, который предсказывает позицию искомого элемента на основе его значения. Как работает: Использует формулу интерполяции для вычисления вероятной позиции элемента. Особенно эффективен при равномерном распределении данных. Сложность: O(log log n) в лучшем случае, O(n) в худшем.

11. Поиск Фибоначчи (Fibonacci Search) Что делает: Использует числа Фибоначчи для определения позиций сравнения в отсортированном массиве. Как работает: Делит массив с помощью чисел Фибоначчи. Сравнивает искомый элемент с элементом на позиции, определяемой числами Фибоначчи, и сужает область поиска. Сложность: O(log n).
